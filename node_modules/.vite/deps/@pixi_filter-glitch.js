import {
  DEG_TO_RAD,
  Filter,
  SCALE_MODES,
  Texture,
  init_constants,
  init_core,
  init_math
} from "./chunk-77HXZFP2.js";
import "./chunk-QOVRSCHT.js";

// node_modules/@pixi/filter-glitch/dist/filter-glitch.esm.js
init_core();
init_constants();
init_math();
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) {
      if (Object.prototype.hasOwnProperty.call(b2, p)) {
        d2[p] = b2[p];
      }
    }
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var vertex = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}";
var fragment = "// precision highp float;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n\nuniform vec4 filterArea;\nuniform vec4 filterClamp;\nuniform vec2 dimensions;\nuniform float aspect;\n\nuniform sampler2D displacementMap;\nuniform float offset;\nuniform float sinDir;\nuniform float cosDir;\nuniform int fillMode;\n\nuniform float seed;\nuniform vec2 red;\nuniform vec2 green;\nuniform vec2 blue;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * aspect;\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\n    } else {\n        if( coord.x > filterClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = filterClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < filterClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += filterClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -filterClamp.z;\n            }\n        }\n\n        if( coord.y > filterClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = filterClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < filterClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += filterClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -filterClamp.w;\n            }\n        }\n    }\n\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\n    gl_FragColor.a = texture2D(uSampler, coord).a;\n}\n";
var GlitchFilter = function(_super) {
  __extends(GlitchFilter2, _super);
  function GlitchFilter2(options) {
    var _this = _super.call(this, vertex, fragment) || this;
    _this.offset = 100;
    _this.fillMode = GlitchFilter2.TRANSPARENT;
    _this.average = false;
    _this.seed = 0;
    _this.minSize = 8;
    _this.sampleSize = 512;
    _this._slices = 0;
    _this._offsets = new Float32Array(1);
    _this._sizes = new Float32Array(1);
    _this._direction = -1;
    _this.uniforms.dimensions = new Float32Array(2);
    _this._canvas = document.createElement("canvas");
    _this._canvas.width = 4;
    _this._canvas.height = _this.sampleSize;
    _this.texture = Texture.from(_this._canvas, { scaleMode: SCALE_MODES.NEAREST });
    Object.assign(_this, GlitchFilter2.defaults, options);
    return _this;
  }
  GlitchFilter2.prototype.apply = function(filterManager, input, output, clear) {
    var _a = input.filterFrame, width = _a.width, height = _a.height;
    this.uniforms.dimensions[0] = width;
    this.uniforms.dimensions[1] = height;
    this.uniforms.aspect = height / width;
    this.uniforms.seed = this.seed;
    this.uniforms.offset = this.offset;
    this.uniforms.fillMode = this.fillMode;
    filterManager.applyFilter(this, input, output, clear);
  };
  GlitchFilter2.prototype._randomizeSizes = function() {
    var arr = this._sizes;
    var last = this._slices - 1;
    var size = this.sampleSize;
    var min = Math.min(this.minSize / size, 0.9 / this._slices);
    if (this.average) {
      var count = this._slices;
      var rest = 1;
      for (var i = 0; i < last; i++) {
        var averageWidth = rest / (count - i);
        var w = Math.max(averageWidth * (1 - Math.random() * 0.6), min);
        arr[i] = w;
        rest -= w;
      }
      arr[last] = rest;
    } else {
      var rest = 1;
      var ratio = Math.sqrt(1 / this._slices);
      for (var i = 0; i < last; i++) {
        var w = Math.max(ratio * rest * Math.random(), min);
        arr[i] = w;
        rest -= w;
      }
      arr[last] = rest;
    }
    this.shuffle();
  };
  GlitchFilter2.prototype.shuffle = function() {
    var arr = this._sizes;
    var last = this._slices - 1;
    for (var i = last; i > 0; i--) {
      var rand = Math.random() * i >> 0;
      var temp = arr[i];
      arr[i] = arr[rand];
      arr[rand] = temp;
    }
  };
  GlitchFilter2.prototype._randomizeOffsets = function() {
    for (var i = 0; i < this._slices; i++) {
      this._offsets[i] = Math.random() * (Math.random() < 0.5 ? -1 : 1);
    }
  };
  GlitchFilter2.prototype.refresh = function() {
    this._randomizeSizes();
    this._randomizeOffsets();
    this.redraw();
  };
  GlitchFilter2.prototype.redraw = function() {
    var size = this.sampleSize;
    var texture = this.texture;
    var ctx = this._canvas.getContext("2d");
    ctx.clearRect(0, 0, 8, size);
    var offset;
    var y = 0;
    for (var i = 0; i < this._slices; i++) {
      offset = Math.floor(this._offsets[i] * 256);
      var height = this._sizes[i] * size;
      var red = offset > 0 ? offset : 0;
      var green = offset < 0 ? -offset : 0;
      ctx.fillStyle = "rgba(" + red + ", " + green + ", 0, 1)";
      ctx.fillRect(0, y >> 0, size, height + 1 >> 0);
      y += height;
    }
    texture.baseTexture.update();
    this.uniforms.displacementMap = texture;
  };
  Object.defineProperty(GlitchFilter2.prototype, "sizes", {
    get: function() {
      return this._sizes;
    },
    set: function(sizes) {
      var len = Math.min(this._slices, sizes.length);
      for (var i = 0; i < len; i++) {
        this._sizes[i] = sizes[i];
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlitchFilter2.prototype, "offsets", {
    get: function() {
      return this._offsets;
    },
    set: function(offsets) {
      var len = Math.min(this._slices, offsets.length);
      for (var i = 0; i < len; i++) {
        this._offsets[i] = offsets[i];
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlitchFilter2.prototype, "slices", {
    get: function() {
      return this._slices;
    },
    set: function(value) {
      if (this._slices === value) {
        return;
      }
      this._slices = value;
      this.uniforms.slices = value;
      this._sizes = this.uniforms.slicesWidth = new Float32Array(value);
      this._offsets = this.uniforms.slicesOffset = new Float32Array(value);
      this.refresh();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlitchFilter2.prototype, "direction", {
    get: function() {
      return this._direction;
    },
    set: function(value) {
      if (this._direction === value) {
        return;
      }
      this._direction = value;
      var radians = value * DEG_TO_RAD;
      this.uniforms.sinDir = Math.sin(radians);
      this.uniforms.cosDir = Math.cos(radians);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlitchFilter2.prototype, "red", {
    get: function() {
      return this.uniforms.red;
    },
    set: function(value) {
      this.uniforms.red = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlitchFilter2.prototype, "green", {
    get: function() {
      return this.uniforms.green;
    },
    set: function(value) {
      this.uniforms.green = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GlitchFilter2.prototype, "blue", {
    get: function() {
      return this.uniforms.blue;
    },
    set: function(value) {
      this.uniforms.blue = value;
    },
    enumerable: false,
    configurable: true
  });
  GlitchFilter2.prototype.destroy = function() {
    var _a;
    (_a = this.texture) === null || _a === void 0 ? void 0 : _a.destroy(true);
    this.texture = this._canvas = this.red = this.green = this.blue = this._sizes = this._offsets = null;
  };
  GlitchFilter2.defaults = {
    slices: 5,
    offset: 100,
    direction: 0,
    fillMode: 0,
    average: false,
    seed: 0,
    red: [0, 0],
    green: [0, 0],
    blue: [0, 0],
    minSize: 8,
    sampleSize: 512
  };
  GlitchFilter2.TRANSPARENT = 0;
  GlitchFilter2.ORIGINAL = 1;
  GlitchFilter2.LOOP = 2;
  GlitchFilter2.CLAMP = 3;
  GlitchFilter2.MIRROR = 4;
  return GlitchFilter2;
}(Filter);
export {
  GlitchFilter
};
/*!
 * @pixi/filter-glitch - v4.1.5
 * Compiled Wed, 29 Sep 2021 14:05:57 UTC
 *
 * @pixi/filter-glitch is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=@pixi_filter-glitch.js.map
